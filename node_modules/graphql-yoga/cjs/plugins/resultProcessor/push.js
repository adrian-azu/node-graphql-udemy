"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processPushResult = void 0;
const core_1 = require("@envelop/core");
const error_js_1 = require("../../error.js");
const stringify_js_1 = require("./stringify.js");
function processPushResult(result, fetchAPI) {
    const timeoutInSeconds = 12;
    const headersInit = {
        'Content-Type': 'text/event-stream',
        Connection: 'keep-alive',
        'Cache-Control': 'no-cache',
        'Content-Encoding': 'none',
    };
    const responseInit = (0, error_js_1.getResponseInitByRespectingErrors)(result, headersInit);
    let iterator;
    let pingInterval;
    const textEncoder = new fetchAPI.TextEncoder();
    const readableStream = new fetchAPI.ReadableStream({
        start(controller) {
            // ping client every 12 seconds to keep the connection alive
            pingInterval = setInterval(() => {
                if (!controller.desiredSize) {
                    clearInterval(pingInterval);
                    return;
                }
                controller.enqueue(textEncoder.encode(':\n\n'));
            }, timeoutInSeconds * 1000);
            if ((0, core_1.isAsyncIterable)(result)) {
                iterator = result[Symbol.asyncIterator]();
            }
            else {
                let finished = false;
                iterator = {
                    next: () => {
                        if (finished) {
                            return Promise.resolve({ done: true, value: null });
                        }
                        finished = true;
                        return Promise.resolve({ done: false, value: result });
                    },
                };
            }
        },
        async pull(controller) {
            const { done, value } = await iterator.next();
            if (value != null) {
                const chunk = (0, stringify_js_1.jsonStringifyResult)(value);
                controller.enqueue(textEncoder.encode(`data: ${chunk}\n\n`));
            }
            if (done) {
                clearInterval(pingInterval);
                controller.close();
            }
        },
        async cancel(e) {
            clearInterval(pingInterval);
            await iterator.return?.(e);
        },
    });
    return new fetchAPI.Response(readableStream, responseInit);
}
exports.processPushResult = processPushResult;
